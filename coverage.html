
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">avito-tech-internship/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">avito-tech-internship/internal/config/config.go (0.0%)</option>
				
				<option value="file2">avito-tech-internship/internal/handler/bulk_deactivate_handler.go (0.0%)</option>
				
				<option value="file3">avito-tech-internship/internal/handler/errors.go (0.0%)</option>
				
				<option value="file4">avito-tech-internship/internal/handler/pullrequest_handler.go (0.0%)</option>
				
				<option value="file5">avito-tech-internship/internal/handler/stats_handler.go (0.0%)</option>
				
				<option value="file6">avito-tech-internship/internal/handler/swagger_handler.go (0.0%)</option>
				
				<option value="file7">avito-tech-internship/internal/handler/team_handler.go (0.0%)</option>
				
				<option value="file8">avito-tech-internship/internal/handler/user_handler.go (0.0%)</option>
				
				<option value="file9">avito-tech-internship/internal/repository/postgres/pullrequest_repository.go (0.0%)</option>
				
				<option value="file10">avito-tech-internship/internal/repository/postgres/team_repository.go (77.8%)</option>
				
				<option value="file11">avito-tech-internship/internal/repository/postgres/user_repository.go (0.0%)</option>
				
				<option value="file12">avito-tech-internship/internal/router/router.go (0.0%)</option>
				
				<option value="file13">avito-tech-internship/internal/service/bulk_deactivate_service.go (0.0%)</option>
				
				<option value="file14">avito-tech-internship/internal/service/pullrequest_service.go (27.4%)</option>
				
				<option value="file15">avito-tech-internship/internal/service/team_service.go (0.0%)</option>
				
				<option value="file16">avito-tech-internship/internal/service/user_service.go (0.0%)</option>
				
				<option value="file17">avito-tech-internship/pkg/migrate/migrate.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "database/sql"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "avito-tech-internship/internal/config"
        "avito-tech-internship/internal/migrations"
        "avito-tech-internship/internal/router"
        "avito-tech-internship/pkg/migrate"

        _ "github.com/lib/pq"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to load config", "error", err)
                os.Exit(1)
        }</span>

        // Initialize logger
        <span class="cov0" title="0">logger := slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: slog.LevelInfo,
        }))
        slog.SetDefault(logger)

        // Connect to database
        db, err := sql.Open("postgres", cfg.DB.DSN())
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to open database", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Test database connection
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to ping database", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">slog.Info("Database connection established")

        // Run migrations
        if err := migrate.RunMigrations(db, migrations.FS); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to run migrations", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">slog.Info("Migrations completed successfully")

        // Setup router
        router := router.SetupRouter(db)

        // Create HTTP server
        srv := &amp;http.Server{
                Addr:         ":" + cfg.Server.Port,
                Handler:      router,
                ReadTimeout:  15 * time.Second,
                WriteTimeout: 15 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        // Start server in goroutine
        go func() </span><span class="cov0" title="0">{
                slog.Info("Starting server", "port", cfg.Server.Port)
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        slog.Error("Server failed to start", "error", err)
                        os.Exit(1)
                }</span>
        }()

        // Graceful shutdown
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        slog.Info("Shutting down server...")

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                slog.Error("Server forced to shutdown", "error", err)
        }</span>

        <span class="cov0" title="0">slog.Info("Server exited")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "os"
)

type Config struct {
        Server ServerConfig
        DB     DBConfig
}

type ServerConfig struct {
        Port string
}

type DBConfig struct {
        Host     string
        Port     string
        User     string
        Password string
        Name     string
        SSLMode  string
}

func Load() (*Config, error) <span class="cov0" title="0">{
        cfg := &amp;Config{
                Server: ServerConfig{
                        Port: getEnv("SERVER_PORT", "8080"),
                },
                DB: DBConfig{
                        Host:     getEnv("DB_HOST", "localhost"),
                        Port:     getEnv("DB_PORT", "5432"),
                        User:     getEnv("DB_USER", "avito"),
                        Password: getEnv("DB_PASSWORD", "avito"),
                        Name:     getEnv("DB_NAME", "avito_db"),
                        SSLMode:  getEnv("DB_SSLMODE", "disable"),
                },
        }

        if err := cfg.validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

func (c *Config) validate() error <span class="cov0" title="0">{
        if c.Server.Port == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("SERVER_PORT is required")
        }</span>
        <span class="cov0" title="0">if c.DB.Host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("DB_HOST is required")
        }</span>
        <span class="cov0" title="0">if c.DB.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("DB_NAME is required")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *DBConfig) DSN() string <span class="cov0" title="0">{
        return fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
                c.Host, c.Port, c.User, c.Password, c.Name, c.SSLMode)
}</span>

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handler

import (
        "encoding/json"
        "log/slog"
        "net/http"
        "time"

        "avito-tech-internship/internal/service"
)

type BulkDeactivateHandler struct {
        bulkDeactivateService *service.BulkDeactivateService
}

func NewBulkDeactivateHandler(bulkDeactivateService *service.BulkDeactivateService) *BulkDeactivateHandler <span class="cov0" title="0">{
        return &amp;BulkDeactivateHandler{bulkDeactivateService: bulkDeactivateService}
}</span>

// BulkDeactivate handles POST /users/bulkDeactivate
func (h *BulkDeactivateHandler) BulkDeactivate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                TeamName string   `json:"team_name"`
                UserIDs  []string `json:"user_ids"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.TeamName == "" </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "team_name is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if len(req.UserIDs) == 0 </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "user_ids is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">startTime := time.Now()
        if err := h.bulkDeactivateService.BulkDeactivate(req.TeamName, req.UserIDs); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to bulk deactivate users", "error", err, "team", req.TeamName, "users", req.UserIDs)
                handleServiceError(w, err)
                return
        }</span>

        <span class="cov0" title="0">duration := time.Since(startTime)
        slog.Info("Bulk deactivation completed",
                "team", req.TeamName,
                "users_count", len(req.UserIDs),
                "duration_ms", duration.Milliseconds())

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        response := map[string]interface{}{
                "deactivated_users": req.UserIDs,
                "team_name":         req.TeamName,
                "duration_ms":       duration.Milliseconds(),
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to encode response", "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "encoding/json"
        "log/slog"
        "net/http"

        "avito-tech-internship/internal/service"
)

// ErrorCode represents error codes from OpenAPI spec
type ErrorCode string

const (
        ErrorCodeTeamExists  ErrorCode = "TEAM_EXISTS"
        ErrorCodePRExists    ErrorCode = "PR_EXISTS"
        ErrorCodePRMerged    ErrorCode = "PR_MERGED"
        ErrorCodeNotAssigned ErrorCode = "NOT_ASSIGNED"
        ErrorCodeNoCandidate ErrorCode = "NO_CANDIDATE"
        ErrorCodeNotFound    ErrorCode = "NOT_FOUND"
)

// ErrorResponse represents error response structure
type ErrorResponse struct {
        Error struct {
                Code    string `json:"code"`
                Message string `json:"message"`
        } `json:"error"`
}

// writeError writes error response with appropriate status code
func writeError(w http.ResponseWriter, code ErrorCode, message string, statusCode int) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        resp := ErrorResponse{}
        resp.Error.Code = string(code)
        resp.Error.Message = message

        if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to encode error response", "error", err)
        }</span>
}

// handleServiceError converts service errors to HTTP responses
func handleServiceError(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        switch err </span>{
        case service.ErrTeamExists:<span class="cov0" title="0">
                writeError(w, ErrorCodeTeamExists, "team_name already exists", http.StatusBadRequest)</span>
        case service.ErrTeamNotFound:<span class="cov0" title="0">
                writeError(w, ErrorCodeNotFound, "team not found", http.StatusNotFound)</span>
        case service.ErrUserNotFound:<span class="cov0" title="0">
                writeError(w, ErrorCodeNotFound, "user not found", http.StatusNotFound)</span>
        case service.ErrPRNotFound:<span class="cov0" title="0">
                writeError(w, ErrorCodeNotFound, "PR not found", http.StatusNotFound)</span>
        case service.ErrPRExists:<span class="cov0" title="0">
                writeError(w, ErrorCodePRExists, "PR id already exists", http.StatusConflict)</span>
        case service.ErrPRMerged:<span class="cov0" title="0">
                writeError(w, ErrorCodePRMerged, "cannot reassign on merged PR", http.StatusConflict)</span>
        case service.ErrNotAssigned:<span class="cov0" title="0">
                writeError(w, ErrorCodeNotAssigned, "reviewer is not assigned to this PR", http.StatusConflict)</span>
        case service.ErrNoCandidate:<span class="cov0" title="0">
                writeError(w, ErrorCodeNoCandidate, "no active replacement candidate in team", http.StatusConflict)</span>
        case service.ErrAuthorNotFound:<span class="cov0" title="0">
                writeError(w, ErrorCodeNotFound, "author/team not found", http.StatusNotFound)</span>
        default:<span class="cov0" title="0">
                slog.Error("Unhandled service error", "error", err)
                writeError(w, ErrorCodeNotFound, "internal server error", http.StatusInternalServerError)</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handler

import (
        "encoding/json"
        "log/slog"
        "net/http"

        "avito-tech-internship/internal/domain"
        "avito-tech-internship/internal/service"
)

type PullRequestHandler struct {
        prService *service.PullRequestService
}

func NewPullRequestHandler(prService *service.PullRequestService) *PullRequestHandler <span class="cov0" title="0">{
        return &amp;PullRequestHandler{prService: prService}
}</span>

// CreatePR handles POST /pullRequest/create
func (h *PullRequestHandler) CreatePR(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                PullRequestID   string `json:"pull_request_id"`
                PullRequestName string `json:"pull_request_name"`
                AuthorID        string `json:"author_id"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">pr := &amp;domain.PullRequest{
                PullRequestID:   req.PullRequestID,
                PullRequestName: req.PullRequestName,
                AuthorID:        req.AuthorID,
        }

        if err := h.prService.CreatePR(pr); err != nil </span><span class="cov0" title="0">{
                handleServiceError(w, err)
                return
        }</span>

        // Get created PR to return full data with assigned reviewers
        <span class="cov0" title="0">createdPR, err := h.prService.GetPR(pr.PullRequestID)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(w, err)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)

        response := map[string]*domain.PullRequest{
                "pr": createdPR,
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to encode response", "error", err)
        }</span>
}

// MergePR handles POST /pullRequest/merge
func (h *PullRequestHandler) MergePR(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                PullRequestID string `json:"pull_request_id"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">pr, err := h.prService.MergePR(req.PullRequestID)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(w, err)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        response := map[string]*domain.PullRequest{
                "pr": pr,
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to encode response", "error", err)
        }</span>
}

// ReassignReviewer handles POST /pullRequest/reassign
func (h *PullRequestHandler) ReassignReviewer(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                PullRequestID string `json:"pull_request_id"`
                OldUserID     string `json:"old_user_id"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">pr, newUserID, err := h.prService.ReassignReviewer(req.PullRequestID, req.OldUserID)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(w, err)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        response := map[string]interface{}{
                "pr":          pr,
                "replaced_by": newUserID,
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to encode response", "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "encoding/json"
        "log/slog"
        "net/http"

        "avito-tech-internship/internal/service"
)

type StatsHandler struct {
        prService *service.PullRequestService
}

func NewStatsHandler(prService *service.PullRequestService) *StatsHandler <span class="cov0" title="0">{
        return &amp;StatsHandler{prService: prService}
}</span>

// GetStats handles GET /stats
func (h *StatsHandler) GetStats(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">stats, err := h.prService.GetStats()
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to get stats", "error", err)
                writeError(w, ErrorCodeNotFound, "failed to get statistics", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        if err := json.NewEncoder(w).Encode(stats); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to encode stats response", "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "embed"
        "io"
        "io/fs"
        "log/slog"
        "net/http"
)

//go:embed swagger-ui/*
var swaggerUI embed.FS

//go:embed openapi.yml
var openAPISpec embed.FS

const indexHTML = "index.html"

// ServeSwaggerUI serves Swagger UI
func ServeSwaggerUI(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        path := r.URL.Path

        // Serve OpenAPI spec
        if path == "/swagger/openapi.yml" || path == "/swagger/openapi.yaml" </span><span class="cov0" title="0">{
                spec, err := openAPISpec.ReadFile("openapi.yml")
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "OpenAPI spec not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/x-yaml")
                if _, err := w.Write(spec); err != nil </span><span class="cov0" title="0">{
                        slog.Error("Failed to write OpenAPI spec", "error", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Serve Swagger UI
        <span class="cov0" title="0">subFS, err := fs.Sub(swaggerUI, "swagger-ui")
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Swagger UI not found", http.StatusNotFound)
                return
        }</span>

        // Remove /swagger prefix and get file path
        <span class="cov0" title="0">filePath := path[len("/swagger"):]
        if filePath == "" || filePath == "/" </span><span class="cov0" title="0">{
                filePath = indexHTML
        }</span> else<span class="cov0" title="0"> {
                // Remove leading slash
                if len(filePath) &gt; 0 &amp;&amp; filePath[0] == '/' </span><span class="cov0" title="0">{
                        filePath = filePath[1:]
                }</span>
        }

        // Open file from embedded FS
        <span class="cov0" title="0">file, err := subFS.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                // If file not found and it's not root, try index.html
                if filePath != indexHTML </span><span class="cov0" title="0">{
                        filePath = indexHTML
                        file, err = subFS.Open(filePath)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "File not found: "+filePath, http.StatusNotFound)
                        return
                }</span>
        }
        <span class="cov0" title="0">defer file.Close()

        // Read file content
        content, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to read file", http.StatusInternalServerError)
                return
        }</span>

        // Set content type based on file extension
        <span class="cov0" title="0">if filePath == indexHTML </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "text/html; charset=utf-8")
        }</span> else<span class="cov0" title="0"> if len(filePath) &gt; 4 &amp;&amp; filePath[len(filePath)-4:] == ".css" </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "text/css")
        }</span> else<span class="cov0" title="0"> if len(filePath) &gt; 3 &amp;&amp; filePath[len(filePath)-3:] == ".js" </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/javascript")
        }</span>

        // Serve file content
        <span class="cov0" title="0">if _, err := w.Write(content); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to write file content", "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "encoding/json"
        "log/slog"
        "net/http"

        "avito-tech-internship/internal/domain"
        "avito-tech-internship/internal/service"
)

type TeamHandler struct {
        teamService *service.TeamService
}

func NewTeamHandler(teamService *service.TeamService) *TeamHandler <span class="cov0" title="0">{
        return &amp;TeamHandler{teamService: teamService}
}</span>

// CreateTeam handles POST /team/add
func (h *TeamHandler) CreateTeam(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var team domain.Team
        if err := json.NewDecoder(r.Body).Decode(&amp;team); err != nil </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.teamService.CreateTeam(&amp;team); err != nil </span><span class="cov0" title="0">{
                handleServiceError(w, err)
                return
        }</span>

        // Get created team to return full data
        <span class="cov0" title="0">createdTeam, err := h.teamService.GetTeam(team.TeamName)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(w, err)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)

        response := map[string]*domain.Team{
                "team": createdTeam,
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to encode response", "error", err)
        }</span>
}

// GetTeam handles GET /team/get?team_name=...
func (h *TeamHandler) GetTeam(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">teamName := r.URL.Query().Get("team_name")
        if teamName == "" </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "team_name parameter is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">team, err := h.teamService.GetTeam(teamName)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(w, err)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        if err := json.NewEncoder(w).Encode(team); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to encode response", "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handler

import (
        "encoding/json"
        "log/slog"
        "net/http"

        "avito-tech-internship/internal/domain"
        "avito-tech-internship/internal/service"
)

type UserHandler struct {
        userService        *service.UserService
        pullRequestService *service.PullRequestService
}

func NewUserHandler(userService *service.UserService, prService *service.PullRequestService) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userService:        userService,
                pullRequestService: prService,
        }
}</span>

// SetIsActive handles POST /users/setIsActive
func (h *UserHandler) SetIsActive(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                UserID   string `json:"user_id"`
                IsActive bool   `json:"is_active"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.SetIsActive(req.UserID, req.IsActive)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(w, err)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        response := map[string]*domain.User{
                "user": user,
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to encode response", "error", err)
        }</span>
}

// GetReview handles GET /users/getReview?user_id=...
func (h *UserHandler) GetReview(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">userID := r.URL.Query().Get("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                writeError(w, ErrorCodeNotFound, "user_id parameter is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">prs, err := h.pullRequestService.GetPRsByReviewer(userID)
        if err != nil </span><span class="cov0" title="0">{
                handleServiceError(w, err)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        response := map[string]interface{}{
                "user_id":       userID,
                "pull_requests": prs,
        }

        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                slog.Error("Failed to encode response", "error", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package postgres

import (
        "database/sql"
        "fmt"
        "strings"
        "time"

        "avito-tech-internship/internal/domain"
        "avito-tech-internship/internal/repository"
)

type pullRequestRepository struct {
        db *sql.DB
}

// NewPullRequestRepository creates a new PostgreSQL pull request repository
func NewPullRequestRepository(db *sql.DB) *pullRequestRepository <span class="cov0" title="0">{
        return &amp;pullRequestRepository{db: db}
}</span>

func (r *pullRequestRepository) CreatePR(pr *domain.PullRequest) error <span class="cov0" title="0">{
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = tx.Rollback() // Ignore error - transaction may already be committed
        }</span>()

        <span class="cov0" title="0">now := time.Now()
        // Create PR
        _, err = tx.Exec(
                `INSERT INTO pull_requests (pull_request_id, pull_request_name, author_id, status, created_at) 
                 VALUES ($1, $2, $3, $4, $5)`,
                pr.PullRequestID, pr.PullRequestName, pr.AuthorID, pr.Status, now,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create PR: %w", err)
        }</span>

        // Assign reviewers
        <span class="cov0" title="0">for _, reviewerID := range pr.AssignedReviewers </span><span class="cov0" title="0">{
                _, err = tx.Exec(
                        "INSERT INTO pr_reviewers (pull_request_id, user_id) VALUES ($1, $2)",
                        pr.PullRequestID, reviewerID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to assign reviewer %s: %w", reviewerID, err)
                }</span>
        }

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit PR creation: %w", err)
        }</span>

        <span class="cov0" title="0">pr.CreatedAt = &amp;now
        return nil</span>
}

func (r *pullRequestRepository) GetPR(prID string) (*domain.PullRequest, error) <span class="cov0" title="0">{
        var pr domain.PullRequest
        var createdAt, mergedAt sql.NullTime

        err := r.db.QueryRow(
                `SELECT pull_request_id, pull_request_name, author_id, status, created_at, merged_at 
                 FROM pull_requests WHERE pull_request_id = $1`,
                prID,
        ).Scan(&amp;pr.PullRequestID, &amp;pr.PullRequestName, &amp;pr.AuthorID, &amp;pr.Status, &amp;createdAt, &amp;mergedAt)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get PR: %w", err)</span>
        }

        <span class="cov0" title="0">if createdAt.Valid </span><span class="cov0" title="0">{
                pr.CreatedAt = &amp;createdAt.Time
        }</span>
        <span class="cov0" title="0">if mergedAt.Valid </span><span class="cov0" title="0">{
                pr.MergedAt = &amp;mergedAt.Time
        }</span>

        // Get assigned reviewers
        <span class="cov0" title="0">rows, err := r.db.Query(
                "SELECT user_id FROM pr_reviewers WHERE pull_request_id = $1 ORDER BY user_id",
                prID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query reviewers: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var reviewerID string
                if err := rows.Scan(&amp;reviewerID); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan reviewer: %w", err)
                }</span>
                <span class="cov0" title="0">pr.AssignedReviewers = append(pr.AssignedReviewers, reviewerID)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating reviewers: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;pr, nil</span>
}

func (r *pullRequestRepository) UpdatePR(pr *domain.PullRequest) error <span class="cov0" title="0">{
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = tx.Rollback() // Ignore error - transaction may already be committed
        }</span>()

        // Update PR
        <span class="cov0" title="0">_, err = tx.Exec(
                `UPDATE pull_requests 
                 SET pull_request_name = $1, status = $2, merged_at = $3 
                 WHERE pull_request_id = $4`,
                pr.PullRequestName, pr.Status, pr.MergedAt, pr.PullRequestID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update PR: %w", err)
        }</span>

        // Delete old reviewers
        <span class="cov0" title="0">_, err = tx.Exec("DELETE FROM pr_reviewers WHERE pull_request_id = $1", pr.PullRequestID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete old reviewers: %w", err)
        }</span>

        // Insert new reviewers
        <span class="cov0" title="0">for _, reviewerID := range pr.AssignedReviewers </span><span class="cov0" title="0">{
                _, err = tx.Exec(
                        "INSERT INTO pr_reviewers (pull_request_id, user_id) VALUES ($1, $2)",
                        pr.PullRequestID, reviewerID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to assign reviewer %s: %w", reviewerID, err)
                }</span>
        }

        <span class="cov0" title="0">return tx.Commit()</span>
}

func (r *pullRequestRepository) MergePR(prID string) (*domain.PullRequest, error) <span class="cov0" title="0">{
        pr, err := r.GetPR(prID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If already merged, return current state (idempotent)
        <span class="cov0" title="0">if pr.Status == domain.PRStatusMerged </span><span class="cov0" title="0">{
                return pr, nil
        }</span>

        <span class="cov0" title="0">now := time.Now()
        pr.Status = domain.PRStatusMerged
        pr.MergedAt = &amp;now

        if err := r.UpdatePR(pr); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return pr, nil</span>
}

func (r *pullRequestRepository) PRExists(prID string) (bool, error) <span class="cov0" title="0">{
        var exists bool
        err := r.db.QueryRow(
                "SELECT EXISTS(SELECT 1 FROM pull_requests WHERE pull_request_id = $1)",
                prID,
        ).Scan(&amp;exists)
        return exists, err
}</span>

func (r *pullRequestRepository) GetPRsByReviewer(userID string) ([]*domain.PullRequestShort, error) <span class="cov0" title="0">{
        rows, err := r.db.Query(
                `SELECT pr.pull_request_id, pr.pull_request_name, pr.author_id, pr.status
                 FROM pull_requests pr
                 INNER JOIN pr_reviewers prr ON pr.pull_request_id = prr.pull_request_id
                 WHERE prr.user_id = $1
                 ORDER BY pr.created_at DESC`,
                userID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query PRs: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var prs []*domain.PullRequestShort
        for rows.Next() </span><span class="cov0" title="0">{
                pr := &amp;domain.PullRequestShort{}
                if err := rows.Scan(&amp;pr.PullRequestID, &amp;pr.PullRequestName, &amp;pr.AuthorID, &amp;pr.Status); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan PR: %w", err)
                }</span>
                <span class="cov0" title="0">prs = append(prs, pr)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating PRs: %w", err)
        }</span>

        <span class="cov0" title="0">return prs, nil</span>
}

func (r *pullRequestRepository) ReassignReviewer(prID string, oldUserID string, newUserID string) error <span class="cov0" title="0">{
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = tx.Rollback() // Ignore error - transaction may already be committed
        }</span>()

        // Check if old reviewer is assigned
        <span class="cov0" title="0">var count int
        err = tx.QueryRow(
                "SELECT COUNT(*) FROM pr_reviewers WHERE pull_request_id = $1 AND user_id = $2",
                prID, oldUserID,
        ).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check reviewer assignment: %w", err)
        }</span>
        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("reviewer not assigned to this PR")
        }</span>

        // Replace reviewer
        <span class="cov0" title="0">_, err = tx.Exec(
                "UPDATE pr_reviewers SET user_id = $1 WHERE pull_request_id = $2 AND user_id = $3",
                newUserID, prID, oldUserID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reassign reviewer: %w", err)
        }</span>

        <span class="cov0" title="0">return tx.Commit()</span>
}

func (r *pullRequestRepository) GetStats() (*domain.Stats, error) <span class="cov0" title="0">{
        stats := &amp;domain.Stats{}

        // Get total PRs count
        err := r.db.QueryRow("SELECT COUNT(*) FROM pull_requests").Scan(&amp;stats.TotalPRs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total PRs: %w", err)
        }</span>

        // Get total users count
        <span class="cov0" title="0">err = r.db.QueryRow("SELECT COUNT(*) FROM users").Scan(&amp;stats.TotalUsers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get total users: %w", err)
        }</span>

        // Get average reviewers per PR
        <span class="cov0" title="0">var avgReviewers sql.NullFloat64
        err = r.db.QueryRow(`
                SELECT COALESCE(AVG(reviewer_count), 0) 
                FROM (
                        SELECT pull_request_id, COUNT(*) as reviewer_count 
                        FROM pr_reviewers 
                        GROUP BY pull_request_id
                ) subq
        `).Scan(&amp;avgReviewers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get average reviewers: %w", err)
        }</span>
        <span class="cov0" title="0">if avgReviewers.Valid </span><span class="cov0" title="0">{
                stats.AverageReviewersPerPR = avgReviewers.Float64
        }</span>

        // Get assignments by user
        <span class="cov0" title="0">rows, err := r.db.Query(`
                SELECT u.user_id, u.username, COUNT(prr.user_id) as assignment_count
                FROM users u
                LEFT JOIN pr_reviewers prr ON u.user_id = prr.user_id
                GROUP BY u.user_id, u.username
                ORDER BY assignment_count DESC
        `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get assignments by user: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var userStat domain.UserAssignmentStats
                if scanErr := rows.Scan(&amp;userStat.UserID, &amp;userStat.Username, &amp;userStat.AssignmentCount); scanErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user stats: %w", scanErr)
                }</span>
                <span class="cov0" title="0">stats.AssignmentsByUser = append(stats.AssignmentsByUser, userStat)</span>
        }
        <span class="cov0" title="0">if scanErr := rows.Err(); scanErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating user stats: %w", scanErr)
        }</span>

        // Get reviewers per PR
        <span class="cov0" title="0">prRows, err := r.db.Query(`
                SELECT pr.pull_request_id, pr.pull_request_name, COUNT(prr.user_id) as reviewer_count
                FROM pull_requests pr
                LEFT JOIN pr_reviewers prr ON pr.pull_request_id = prr.pull_request_id
                GROUP BY pr.pull_request_id, pr.pull_request_name
                ORDER BY reviewer_count DESC
        `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get reviewers per PR: %w", err)
        }</span>
        <span class="cov0" title="0">defer prRows.Close()

        for prRows.Next() </span><span class="cov0" title="0">{
                var prStat domain.PRReviewerStats
                if err := prRows.Scan(&amp;prStat.PRID, &amp;prStat.PRName, &amp;prStat.ReviewerCount); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan PR stats: %w", err)
                }</span>
                <span class="cov0" title="0">stats.ReviewersPerPR = append(stats.ReviewersPerPR, prStat)</span>
        }
        <span class="cov0" title="0">if err := prRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating PR stats: %w", err)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

func (r *pullRequestRepository) GetOpenPRsByReviewers(userIDs []string) ([]*domain.PullRequest, error) <span class="cov0" title="0">{
        if len(userIDs) == 0 </span><span class="cov0" title="0">{
                return []*domain.PullRequest{}, nil
        }</span>

        // Build query with placeholders
        <span class="cov0" title="0">placeholders := make([]string, len(userIDs))
        args := make([]interface{}, len(userIDs))
        for i, userID := range userIDs </span><span class="cov0" title="0">{
                args[i] = userID
                placeholders[i] = fmt.Sprintf("$%d", i+1)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT DISTINCT pr.pull_request_id, pr.pull_request_name, pr.author_id, pr.status, pr.created_at, pr.merged_at
                FROM pull_requests pr
                INNER JOIN pr_reviewers prr ON pr.pull_request_id = prr.pull_request_id
                WHERE pr.status = 'OPEN' AND prr.user_id IN (%s)
                ORDER BY pr.created_at DESC
        `, strings.Join(placeholders, ", "))

        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query open PRs: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var prs []*domain.PullRequest
        prMap := make(map[string]*domain.PullRequest)

        for rows.Next() </span><span class="cov0" title="0">{
                var pr domain.PullRequest
                var createdAt, mergedAt sql.NullTime

                if scanErr := rows.Scan(
                        &amp;pr.PullRequestID,
                        &amp;pr.PullRequestName,
                        &amp;pr.AuthorID,
                        &amp;pr.Status,
                        &amp;createdAt,
                        &amp;mergedAt,
                ); scanErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan PR: %w", scanErr)
                }</span>

                <span class="cov0" title="0">if createdAt.Valid </span><span class="cov0" title="0">{
                        pr.CreatedAt = &amp;createdAt.Time
                }</span>
                <span class="cov0" title="0">if mergedAt.Valid </span><span class="cov0" title="0">{
                        pr.MergedAt = &amp;mergedAt.Time
                }</span>

                // Store PR if not already seen
                <span class="cov0" title="0">if _, exists := prMap[pr.PullRequestID]; !exists </span><span class="cov0" title="0">{
                        prMap[pr.PullRequestID] = &amp;pr
                }</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating PRs: %w", err)
        }</span>

        // Convert map to slice
        <span class="cov0" title="0">for _, pr := range prMap </span><span class="cov0" title="0">{
                prs = append(prs, pr)
        }</span>

        // Get reviewers for each PR
        <span class="cov0" title="0">for _, pr := range prs </span><span class="cov0" title="0">{
                reviewerRows, err := r.db.Query(
                        "SELECT user_id FROM pr_reviewers WHERE pull_request_id = $1 ORDER BY user_id",
                        pr.PullRequestID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to query reviewers for PR %s: %w", pr.PullRequestID, err)
                }</span>

                <span class="cov0" title="0">for reviewerRows.Next() </span><span class="cov0" title="0">{
                        var reviewerID string
                        if err := reviewerRows.Scan(&amp;reviewerID); err != nil </span><span class="cov0" title="0">{
                                reviewerRows.Close()
                                return nil, fmt.Errorf("failed to scan reviewer: %w", err)
                        }</span>
                        <span class="cov0" title="0">pr.AssignedReviewers = append(pr.AssignedReviewers, reviewerID)</span>
                }
                <span class="cov0" title="0">reviewerRows.Close()</span>
        }

        <span class="cov0" title="0">return prs, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package postgres

import (
        "database/sql"
        "fmt"

        "avito-tech-internship/internal/domain"
        "avito-tech-internship/internal/repository"
)

type teamRepository struct {
        db *sql.DB
}

// NewTeamRepository creates a new PostgreSQL team repository
func NewTeamRepository(db *sql.DB) *teamRepository <span class="cov8" title="1">{
        return &amp;teamRepository{db: db}
}</span>

func (r *teamRepository) CreateTeam(team *domain.Team) error <span class="cov8" title="1">{
        tx, err := r.db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                _ = tx.Rollback() // Ignore error - transaction may already be committed
        }</span>()

        // Create team
        <span class="cov8" title="1">_, err = tx.Exec(
                "INSERT INTO teams (team_name) VALUES ($1) ON CONFLICT (team_name) DO NOTHING",
                team.TeamName,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create team: %w", err)
        }</span>

        // Create or update users
        <span class="cov8" title="1">for _, member := range team.Members </span><span class="cov8" title="1">{
                _, err = tx.Exec(
                        `INSERT INTO users (user_id, username, team_name, is_active) 
                         VALUES ($1, $2, $3, $4)
                         ON CONFLICT (user_id) 
                         DO UPDATE SET username = $2, team_name = $3, is_active = $4, updated_at = CURRENT_TIMESTAMP`,
                        member.UserID, member.Username, team.TeamName, member.IsActive,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create/update user %s: %w", member.UserID, err)
                }</span>
        }

        <span class="cov8" title="1">return tx.Commit()</span>
}

func (r *teamRepository) GetTeam(teamName string) (*domain.Team, error) <span class="cov8" title="1">{
        // Check if team exists
        var exists bool
        err := r.db.QueryRow(
                "SELECT EXISTS(SELECT 1 FROM teams WHERE team_name = $1)",
                teamName,
        ).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check team existence: %w", err)
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                return nil, repository.ErrNotFound
        }</span>

        // Get team members
        <span class="cov8" title="1">rows, err := r.db.Query(
                "SELECT user_id, username, is_active FROM users WHERE team_name = $1 ORDER BY user_id",
                teamName,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query team members: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var members []domain.TeamMember
        for rows.Next() </span><span class="cov8" title="1">{
                var member domain.TeamMember
                if err := rows.Scan(&amp;member.UserID, &amp;member.Username, &amp;member.IsActive); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan team member: %w", err)
                }</span>
                <span class="cov8" title="1">members = append(members, member)</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating team members: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;domain.Team{
                TeamName: teamName,
                Members:  members,
        }, nil</span>
}

func (r *teamRepository) TeamExists(teamName string) (bool, error) <span class="cov8" title="1">{
        var exists bool
        err := r.db.QueryRow(
                "SELECT EXISTS(SELECT 1 FROM teams WHERE team_name = $1)",
                teamName,
        ).Scan(&amp;exists)
        return exists, err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package postgres

import (
        "database/sql"
        "fmt"
        "strings"

        "avito-tech-internship/internal/domain"
        "avito-tech-internship/internal/repository"
)

type userRepository struct {
        db *sql.DB
}

// NewUserRepository creates a new PostgreSQL user repository
func NewUserRepository(db *sql.DB) *userRepository <span class="cov0" title="0">{
        return &amp;userRepository{db: db}
}</span>

func (r *userRepository) GetUser(userID string) (*domain.User, error) <span class="cov0" title="0">{
        var user domain.User
        err := r.db.QueryRow(
                "SELECT user_id, username, team_name, is_active FROM users WHERE user_id = $1",
                userID,
        ).Scan(&amp;user.UserID, &amp;user.Username, &amp;user.TeamName, &amp;user.IsActive)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, repository.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }
        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (r *userRepository) SetIsActive(userID string, isActive bool) (*domain.User, error) <span class="cov0" title="0">{
        _, err := r.db.Exec(
                "UPDATE users SET is_active = $1, updated_at = CURRENT_TIMESTAMP WHERE user_id = $2",
                isActive, userID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user activity: %w", err)
        }</span>

        <span class="cov0" title="0">return r.GetUser(userID)</span>
}

func (r *userRepository) GetActiveUsersByTeam(teamName string, excludeUserIDs []string) ([]*domain.User, error) <span class="cov0" title="0">{
        query := "SELECT user_id, username, team_name, is_active FROM users WHERE team_name = $1 AND is_active = true"
        args := []interface{}{teamName}

        if len(excludeUserIDs) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := make([]string, len(excludeUserIDs))
                for i, id := range excludeUserIDs </span><span class="cov0" title="0">{
                        args = append(args, id)
                        placeholders[i] = fmt.Sprintf("$%d", i+2) // +2 because $1 is teamName
                }</span>
                <span class="cov0" title="0">query += fmt.Sprintf(" AND user_id NOT IN (%s)", strings.Join(placeholders, ", "))</span>
        }

        <span class="cov0" title="0">query += " ORDER BY user_id"

        rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query active users: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []*domain.User
        for rows.Next() </span><span class="cov0" title="0">{
                var user domain.User
                if err := rows.Scan(&amp;user.UserID, &amp;user.Username, &amp;user.TeamName, &amp;user.IsActive); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user: %w", err)
                }</span>
                <span class="cov0" title="0">users = append(users, &amp;user)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating users: %w", err)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

func (r *userRepository) CreateOrUpdateUser(user *domain.User) error <span class="cov0" title="0">{
        _, err := r.db.Exec(
                `INSERT INTO users (user_id, username, team_name, is_active) 
                 VALUES ($1, $2, $3, $4)
                 ON CONFLICT (user_id) 
                 DO UPDATE SET username = $2, team_name = $3, is_active = $4, updated_at = CURRENT_TIMESTAMP`,
                user.UserID, user.Username, user.TeamName, user.IsActive,
        )
        return err
}</span>

func (r *userRepository) BulkSetIsActive(userIDs []string, isActive bool) error <span class="cov0" title="0">{
        if len(userIDs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Build query with placeholders
        <span class="cov0" title="0">placeholders := make([]string, len(userIDs))
        args := make([]interface{}, len(userIDs)+1)
        args[0] = isActive
        for i, userID := range userIDs </span><span class="cov0" title="0">{
                args[i+1] = userID
                placeholders[i] = fmt.Sprintf("$%d", i+2)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                UPDATE users 
                SET is_active = $1, updated_at = CURRENT_TIMESTAMP 
                WHERE user_id IN (%s)
        `, strings.Join(placeholders, ", "))

        _, err := r.db.Exec(query, args...)
        return err</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package router

import (
        "database/sql"
        "net/http"
        "time"

        "avito-tech-internship/internal/handler"
        "avito-tech-internship/internal/repository/postgres"
        "avito-tech-internship/internal/service"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
)

// SetupRouter creates and configures the HTTP router with all routes
func SetupRouter(db *sql.DB) *chi.Mux <span class="cov0" title="0">{
        r := chi.NewRouter()

        // Middleware
        r.Use(middleware.RequestID)
        r.Use(middleware.RealIP)
        r.Use(middleware.Logger)
        r.Use(middleware.Recoverer)
        r.Use(middleware.Timeout(60 * time.Second))

        // Health check endpoint
        r.Get("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                _, _ = w.Write([]byte(`{"status":"ok"}`)) // Ignore write errors for health check
        }</span>)

        // Swagger UI
        <span class="cov0" title="0">r.Get("/swagger", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/swagger/", http.StatusMovedPermanently)
        }</span>)
        <span class="cov0" title="0">r.Get("/swagger/", handler.ServeSwaggerUI)
        r.HandleFunc("/swagger/*", handler.ServeSwaggerUI)

        // Initialize repositories
        teamRepo := postgres.NewTeamRepository(db)
        userRepo := postgres.NewUserRepository(db)
        prRepo := postgres.NewPullRequestRepository(db)

        // Initialize services
        teamService := service.NewTeamService(teamRepo)
        userService := service.NewUserService(userRepo)
        prService := service.NewPullRequestService(prRepo, userRepo, teamRepo)
        bulkDeactivateService := service.NewBulkDeactivateService(userRepo, prRepo, teamRepo)

        // Initialize handlers
        teamHandler := handler.NewTeamHandler(teamService)
        userHandler := handler.NewUserHandler(userService, prService)
        prHandler := handler.NewPullRequestHandler(prService)
        statsHandler := handler.NewStatsHandler(prService)
        bulkDeactivateHandler := handler.NewBulkDeactivateHandler(bulkDeactivateService)

        // API routes
        r.Route("/team", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/add", teamHandler.CreateTeam)
                r.Get("/get", teamHandler.GetTeam)
        }</span>)

        <span class="cov0" title="0">r.Route("/users", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/setIsActive", userHandler.SetIsActive)
                r.Get("/getReview", userHandler.GetReview)
                r.Post("/bulkDeactivate", bulkDeactivateHandler.BulkDeactivate)
        }</span>)

        <span class="cov0" title="0">r.Route("/pullRequest", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/create", prHandler.CreatePR)
                r.Post("/merge", prHandler.MergePR)
                r.Post("/reassign", prHandler.ReassignReviewer)
        }</span>)

        // Statistics endpoint
        <span class="cov0" title="0">r.Get("/stats", statsHandler.GetStats)

        return r</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package service

import (
        "fmt"

        "avito-tech-internship/internal/repository"
)

// BulkDeactivateService handles bulk deactivation of users with safe PR reassignment
type BulkDeactivateService struct {
        userRepo repository.UserRepository
        prRepo   repository.PullRequestRepository
        teamRepo repository.TeamRepository
}

func NewBulkDeactivateService(
        userRepo repository.UserRepository,
        prRepo repository.PullRequestRepository,
        teamRepo repository.TeamRepository,
) *BulkDeactivateService <span class="cov0" title="0">{
        return &amp;BulkDeactivateService{
                userRepo: userRepo,
                prRepo:   prRepo,
                teamRepo: teamRepo,
        }
}</span>

// BulkDeactivate deactivates multiple users in a team and safely reassigns reviewers in open PRs
func (s *BulkDeactivateService) BulkDeactivate(teamName string, userIDs []string) error <span class="cov0" title="0">{
        if len(userIDs) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no users provided")
        }</span>

        // Validate team exists
        <span class="cov0" title="0">_, err := s.teamRepo.GetTeam(teamName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("team not found: %w", err)
        }</span>

        // Validate all users belong to the team
        <span class="cov0" title="0">for _, userID := range userIDs </span><span class="cov0" title="0">{
                user, getUserErr := s.userRepo.GetUser(userID)
                if getUserErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("user %s not found: %w", userID, getUserErr)
                }</span>
                <span class="cov0" title="0">if user.TeamName != teamName </span><span class="cov0" title="0">{
                        return fmt.Errorf("user %s does not belong to team %s", userID, teamName)
                }</span>
        }

        // Get all open PRs where these users are reviewers
        <span class="cov0" title="0">openPRs, err := s.prRepo.GetOpenPRsByReviewers(userIDs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get open PRs: %w", err)
        }</span>

        // Deactivate users
        <span class="cov0" title="0">if err := s.userRepo.BulkSetIsActive(userIDs, false); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deactivate users: %w", err)
        }</span>

        // Reassign reviewers in open PRs
        <span class="cov0" title="0">for _, pr := range openPRs </span><span class="cov0" title="0">{
                // Find deactivated reviewers in this PR
                deactivatedReviewers := make([]string, 0)
                for _, reviewerID := range pr.AssignedReviewers </span><span class="cov0" title="0">{
                        for _, deactivatedID := range userIDs </span><span class="cov0" title="0">{
                                if reviewerID == deactivatedID </span><span class="cov0" title="0">{
                                        deactivatedReviewers = append(deactivatedReviewers, reviewerID)
                                        break</span>
                                }
                        }
                }

                // Reassign each deactivated reviewer
                <span class="cov0" title="0">for _, oldReviewerID := range deactivatedReviewers </span><span class="cov0" title="0">{
                        // Get old reviewer's team
                        oldReviewer, err := s.userRepo.GetUser(oldReviewerID)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip if user not found
                        }

                        // Get active users from the same team (excluding deactivated and current reviewers)
                        <span class="cov0" title="0">excludeIDs := append(userIDs, pr.AssignedReviewers...)
                        candidates, err := s.userRepo.GetActiveUsersByTeam(oldReviewer.TeamName, excludeIDs)
                        if err != nil || len(candidates) == 0 </span><span class="cov0" title="0">{
                                // No replacement available - remove reviewer
                                // This is safe as PR can have 0-2 reviewers
                                continue</span>
                        }

                        // Select first candidate (simple strategy, can be improved)
                        <span class="cov0" title="0">newReviewerID := candidates[0].UserID

                        // Reassign reviewer
                        if err := s.prRepo.ReassignReviewer(pr.PullRequestID, oldReviewerID, newReviewerID); err != nil </span><span class="cov0" title="0">{
                                // Log error but continue with other PRs
                                // In production, you might want to rollback or handle this differently
                                continue</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package service

import (
        "errors"
        "fmt"
        "math/rand"

        "avito-tech-internship/internal/domain"
        "avito-tech-internship/internal/repository"
)

var (
        ErrPRNotFound     = errors.New("PR not found")
        ErrPRExists       = errors.New("PR already exists")
        ErrPRMerged       = errors.New("PR is merged")
        ErrNotAssigned    = errors.New("reviewer is not assigned")
        ErrNoCandidate    = errors.New("no active replacement candidate")
        ErrAuthorNotFound = errors.New("author not found")
)

type PullRequestService struct {
        prRepo   repository.PullRequestRepository
        userRepo repository.UserRepository
        teamRepo repository.TeamRepository
}

func NewPullRequestService(
        prRepo repository.PullRequestRepository,
        userRepo repository.UserRepository,
        teamRepo repository.TeamRepository,
) *PullRequestService <span class="cov8" title="1">{
        return &amp;PullRequestService{
                prRepo:   prRepo,
                userRepo: userRepo,
                teamRepo: teamRepo,
        }
}</span>

// CreatePR creates a new PR and automatically assigns up to 2 active reviewers from author's team
func (s *PullRequestService) CreatePR(pr *domain.PullRequest) error <span class="cov8" title="1">{
        // Check if PR already exists
        exists, err := s.prRepo.PRExists(pr.PullRequestID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check PR existence: %w", err)
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov0" title="0">{
                return ErrPRExists
        }</span>

        // Get author to find their team
        <span class="cov8" title="1">author, err := s.userRepo.GetUser(pr.AuthorID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        return ErrAuthorNotFound
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get author: %w", err)</span>
        }

        // Get active users from author's team (excluding author)
        <span class="cov8" title="1">candidates, err := s.userRepo.GetActiveUsersByTeam(author.TeamName, []string{pr.AuthorID})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get active users: %w", err)
        }</span>

        // Assign up to 2 reviewers randomly
        <span class="cov8" title="1">pr.AssignedReviewers = s.selectReviewers(candidates, 2)

        // Set status to OPEN
        pr.Status = domain.PRStatusOpen

        // Create PR
        if err := s.prRepo.CreatePR(pr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create PR: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// MergePR marks a PR as merged (idempotent operation)
func (s *PullRequestService) MergePR(prID string) (*domain.PullRequest, error) <span class="cov8" title="1">{
        pr, err := s.prRepo.MergePR(prID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrPRNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to merge PR: %w", err)</span>
        }
        <span class="cov8" title="1">return pr, nil</span>
}

// ReassignReviewer replaces one reviewer with another random active user from the replaced reviewer's team
func (s *PullRequestService) ReassignReviewer(prID string, oldUserID string) (*domain.PullRequest, string, error) <span class="cov0" title="0">{
        // Get PR
        pr, err := s.prRepo.GetPR(prID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, "", ErrPRNotFound
                }</span>
                <span class="cov0" title="0">return nil, "", fmt.Errorf("failed to get PR: %w", err)</span>
        }

        // Check if PR is merged
        <span class="cov0" title="0">if pr.Status == domain.PRStatusMerged </span><span class="cov0" title="0">{
                return nil, "", ErrPRMerged
        }</span>

        // Check if old reviewer is assigned
        <span class="cov0" title="0">found := false
        for _, reviewerID := range pr.AssignedReviewers </span><span class="cov0" title="0">{
                if reviewerID == oldUserID </span><span class="cov0" title="0">{
                        found = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return nil, "", ErrNotAssigned
        }</span>

        // Get old reviewer to find their team
        <span class="cov0" title="0">oldReviewer, err := s.userRepo.GetUser(oldUserID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, "", ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, "", fmt.Errorf("failed to get old reviewer: %w", err)</span>
        }

        // Get active users from old reviewer's team (excluding old reviewer and other current reviewers)
        <span class="cov0" title="0">excludeIDs := []string{oldUserID}
        // Also exclude other current reviewers to avoid duplicates
        for _, reviewerID := range pr.AssignedReviewers </span><span class="cov0" title="0">{
                if reviewerID != oldUserID </span><span class="cov0" title="0">{
                        excludeIDs = append(excludeIDs, reviewerID)
                }</span>
        }

        <span class="cov0" title="0">candidates, err := s.userRepo.GetActiveUsersByTeam(oldReviewer.TeamName, excludeIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to get active users: %w", err)
        }</span>

        <span class="cov0" title="0">if len(candidates) == 0 </span><span class="cov0" title="0">{
                return nil, "", ErrNoCandidate
        }</span>

        // Select random replacement
        <span class="cov0" title="0">newReviewer := s.selectReviewers(candidates, 1)
        if len(newReviewer) == 0 </span><span class="cov0" title="0">{
                return nil, "", ErrNoCandidate
        }</span>
        <span class="cov0" title="0">newUserID := newReviewer[0]

        // Reassign reviewer
        if reassignErr := s.prRepo.ReassignReviewer(prID, oldUserID, newUserID); reassignErr != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to reassign reviewer: %w", reassignErr)
        }</span>

        // Get updated PR
        <span class="cov0" title="0">updatedPR, err := s.prRepo.GetPR(prID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to get updated PR: %w", err)
        }</span>

        <span class="cov0" title="0">return updatedPR, newUserID, nil</span>
}

// GetPRsByReviewer returns all PRs where the user is assigned as reviewer
func (s *PullRequestService) GetPRsByReviewer(userID string) ([]*domain.PullRequestShort, error) <span class="cov0" title="0">{
        // Check if user exists
        _, err := s.userRepo.GetUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">prs, err := s.prRepo.GetPRsByReviewer(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get PRs by reviewer: %w", err)
        }</span>

        <span class="cov0" title="0">return prs, nil</span>
}

// selectReviewers randomly selects up to maxCount reviewers from candidates
func (s *PullRequestService) selectReviewers(candidates []*domain.User, maxCount int) []string <span class="cov8" title="1">{
        if len(candidates) == 0 </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        // Shuffle candidates
        <span class="cov8" title="1">shuffled := make([]*domain.User, len(candidates))
        copy(shuffled, candidates)
        // Use global random generator (no need to seed in Go 1.20+)
        rand.Shuffle(len(shuffled), func(i, j int) </span><span class="cov8" title="1">{
                shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
        }</span>)

        // Select up to maxCount
        <span class="cov8" title="1">count := maxCount
        if len(shuffled) &lt; maxCount </span><span class="cov0" title="0">{
                count = len(shuffled)
        }</span>

        <span class="cov8" title="1">reviewers := make([]string, 0, count)
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                reviewers = append(reviewers, shuffled[i].UserID)
        }</span>

        <span class="cov8" title="1">return reviewers</span>
}

// GetPR retrieves a PR by ID
func (s *PullRequestService) GetPR(prID string) (*domain.PullRequest, error) <span class="cov0" title="0">{
        pr, err := s.prRepo.GetPR(prID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrPRNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get PR: %w", err)</span>
        }
        <span class="cov0" title="0">return pr, nil</span>
}

// GetStats retrieves statistics about PR assignments
func (s *PullRequestService) GetStats() (*domain.Stats, error) <span class="cov0" title="0">{
        stats, err := s.prRepo.GetStats()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get stats: %w", err)
        }</span>
        <span class="cov0" title="0">return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package service

import (
        "errors"
        "fmt"

        "avito-tech-internship/internal/domain"
        "avito-tech-internship/internal/repository"
)

var (
        ErrTeamExists   = errors.New("team already exists")
        ErrTeamNotFound = errors.New("team not found")
)

type TeamService struct {
        teamRepo repository.TeamRepository
}

func NewTeamService(teamRepo repository.TeamRepository) *TeamService <span class="cov0" title="0">{
        return &amp;TeamService{teamRepo: teamRepo}
}</span>

// CreateTeam creates a new team with members (creates/updates users)
func (s *TeamService) CreateTeam(team *domain.Team) error <span class="cov0" title="0">{
        // Check if team already exists
        exists, err := s.teamRepo.TeamExists(team.TeamName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check team existence: %w", err)
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return ErrTeamExists
        }</span>

        // Create team and members
        <span class="cov0" title="0">if err := s.teamRepo.CreateTeam(team); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create team: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetTeam retrieves a team by name with all its members
func (s *TeamService) GetTeam(teamName string) (*domain.Team, error) <span class="cov0" title="0">{
        team, err := s.teamRepo.GetTeam(teamName)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrTeamNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get team: %w", err)</span>
        }
        <span class="cov0" title="0">return team, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package service

import (
        "errors"
        "fmt"

        "avito-tech-internship/internal/domain"
        "avito-tech-internship/internal/repository"
)

var (
        ErrUserNotFound = errors.New("user not found")
)

type UserService struct {
        userRepo repository.UserRepository
}

func NewUserService(userRepo repository.UserRepository) *UserService <span class="cov0" title="0">{
        return &amp;UserService{userRepo: userRepo}
}</span>

// SetIsActive updates the is_active flag for a user
func (s *UserService) SetIsActive(userID string, isActive bool) (*domain.User, error) <span class="cov0" title="0">{
        user, err := s.userRepo.SetIsActive(userID, isActive)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to set user activity: %w", err)</span>
        }
        <span class="cov0" title="0">return user, nil</span>
}

// GetUser retrieves a user by ID
func (s *UserService) GetUser(userID string) (*domain.User, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }
        <span class="cov0" title="0">return user, nil</span>
}

// GetActiveUsersByTeam returns all active users in a team (excluding specified user IDs)
func (s *UserService) GetActiveUsersByTeam(teamName string, excludeUserIDs []string) ([]*domain.User, error) <span class="cov0" title="0">{
        users, err := s.userRepo.GetActiveUsersByTeam(teamName, excludeUserIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get active users: %w", err)
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package migrate

import (
        "database/sql"
        "embed"
        "fmt"
        "log/slog"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        "github.com/golang-migrate/migrate/v4/source/iofs"
        _ "github.com/lib/pq"
)

// RunMigrations runs SQL migrations using golang-migrate library
func RunMigrations(db *sql.DB, migrationsFS embed.FS) error <span class="cov0" title="0">{
        // Create postgres driver instance
        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create postgres driver: %w", err)
        }</span>

        // Create io/fs driver from embed.FS
        // Files are embedded from internal/migrations package
        // The root path is "." since files are embedded directly
        <span class="cov0" title="0">d, err := iofs.New(migrationsFS, ".")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create iofs driver: %w", err)
        }</span>

        // Create migrate instance
        <span class="cov0" title="0">m, err := migrate.NewWithInstance("iofs", d, "postgres", driver)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrate instance: %w", err)
        }</span>

        // Run migrations up
        <span class="cov0" title="0">if err := m.Up(); err != nil </span><span class="cov0" title="0">{
                // ErrNoChange is not an error - it means we're already at the latest version
                if err == migrate.ErrNoChange </span><span class="cov0" title="0">{
                        slog.Info("No migrations to apply - database is up to date")
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to run migrations: %w", err)</span>
        }

        <span class="cov0" title="0">slog.Info("Migrations applied successfully")
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
